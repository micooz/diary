{"data":"\u003Ch1 id=\"angular2-\"\u003EAngular2 事件绑定注意\u003C\u002Fh1\u003E\n\u003Cpre\u003E\u003Ccode class=\"lang-html\"\u003E&lt;select [(ngModel)]=&quot;value&quot; (change)=&quot;onSelect(value)&quot;&gt;\n  ...\n&lt;\u002Fselect&gt;\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre\u003E\u003Ccode class=\"lang-javascript\"\u003EonSelect(value) {\n  \u002F\u002F value 还是原来的值，没来得及改变\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E\u003Cstrong\u003E解决办法\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"lang-javascript\"\u003EonSelect(value) {\n  setTimeout(() =&gt; {\n    \u002F\u002F value 绑定完成后的值\n  });\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch1 id=\"console-log-chrome-devtools-\"\u003Econsole.log 或者说Chrome DevTools的坑\u003C\u002Fh1\u003E\n\u003Cp\u003E考虑下面的代码：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"lang-javascript\"\u003Elet obj = {a: []}, n = 100;\nwhile(n--) {\n  obj.a.push(n);\n}\nconsole.log(obj); \u002F\u002F obj.a[50]: -100\n\nobj.a[50] = -100;\nconsole.log(obj); \u002F\u002F obj.a[50]: -100\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E浏览器里可以发现两次输出的结果中 \u003Ccode\u003Ea[50]\u003C\u002Fcode\u003E 都是 \u003Ccode\u003E-100\u003C\u002Fcode\u003E。这一点如果第一次遇到的话还真是匪夷所思。\u003C\u002Fp\u003E\n\u003Cp\u003E这里我故意把 \u003Ccode\u003Ea\u003C\u002Fcode\u003E 数组的元素弄得很多，使 \u003Ccode\u003EDevTools\u003C\u002Fcode\u003E 以 \u003Cstrong\u003E折叠\u003C\u002Fstrong\u003E 方式显示：\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EObject {a: Array[100]}\nObject {a: Array[100]}\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E看似友好的显示方式，实际上里面有很大的问题。\u003C\u002Fp\u003E\n\u003Cp\u003E当我们\u003Cstrong\u003E展开第一个输出\u003C\u002Fstrong\u003E时， \u003Ccode\u003EDevTools\u003C\u002Fcode\u003E 会 \u003Cstrong\u003E及时\u003C\u002Fstrong\u003E 读取变量值，由于这是个 \u003Cstrong\u003E引用\u003C\u002Fstrong\u003E 类型，实际上它读到的是 \u003Ccode\u003Eobj\u003C\u002Fcode\u003E 的最终值，及 \u003Ccode\u003Ea[50]\u003C\u002Fcode\u003E 是 \u003Ccode\u003E-100\u003C\u002Fcode\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E如果数组a只有很少的元素，\u003Ccode\u003EDevTools\u003C\u002Fcode\u003E 不启用智能显示时就不会出现这个问题。\u003C\u002Fp\u003E\n\u003Cp\u003E也就是说，\u003Ccode\u003Econsole.log\u003C\u002Fcode\u003E 到 \u003Ccode\u003EDevTools\u003C\u002Fcode\u003E 里的实际上\u003Cstrong\u003E是引用而不是拷贝\u003C\u002Fstrong\u003E，\u003Cstrong\u003E展开\u003C\u002Fstrong\u003E操作会及时读取变量值。\u003C\u002Fp\u003E\n\u003Cp\u003E如果把上面例子的两个输出改成：\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode class=\"lang-javascript\"\u003Econsole.log(JSON.stringify(obj));\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E结果将和预期的一致。\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003E因此\u003C\u002Fstrong\u003E，在浏览器中调试 \u003Ccode\u003Ejs\u003C\u002Fcode\u003E 程序应该以 \u003Ccode\u003E调试器\u003C\u002Fcode\u003E 下断点为主，日志为辅。\u003C\u002Fp\u003E\n"}